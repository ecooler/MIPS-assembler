/***
  * Scanning starter code for CS241 A3
  * Currently the alphabet is unused and exists only for self-documenting code
  * This file consists of utilities for Asm.scala and should not need to be modified.
  * Created by Sean Harrap for CS241 in Winter 2017
  */

object Scanning {

  /* It might be more efficient to define states as Symbols or something similar,
     but we use Strings for simplicity here. Feel free to change this.
   */
  case class DFA(states: Set[String], alphabet: Set[Char], transition: PartialFunction[(String, Char), String],
            start: String, accepting: Set[String]) {
    /* Scala tip: single-argument member functions can be written in infix style without . or ()s
     * Don't use this if it hurts readability.
     */
    require(accepting subsetOf states)
    require(states contains start)

    /* This is unused elsewhere, but exists for completeness' sake.
     * It is extremely similar to scanOne in simplifiedMaximalMunch below, except it runs until
     * input is exhausted in all cases.
     */
    def recognize(input: Seq[Char], state: String = start): Boolean =
      if (input.isEmpty) accepting contains state
      else if (transition.isDefinedAt((state,input.head))) recognize(input.tail,transition((state,input.head)))
      else false

      /* recognize can also be defined in terms of abstract list functions, for example:
       * input.foldLeft(Some(start): Option[String])((st, ch) => st.flatMap(x => transition.lift((x, ch)))) match {
       *   case Some(state) => accepting contains state
       *   case None        => false
       * }
       */
  }

  /* A list of all keywords beginning with a dot. You are only required to support .WORD,
   * but a full CS241 MIPS assembler would support .IMPORT and .EXPORT as well.
   */
  val asmDotKeywords: Set[String] = Set("WORD")

  /* A list of all tokens which can be generated by scanning CS241 MIPS assembly code */
  val asmTokens: Set[String]      = asmDotKeywords ++ Set("ID", "LABEL",
                                    "DOTID", "HEXINT", "INT", "ZERO", "COMMA", "REG", "LPAREN", "RPAREN")

  /* A DFA for CS241 MIPS. You'll learn more about DFAs and how they work about halfway
   * through the term, and can modify this when completing Assignment 6. For now it will work unchanged.
   */
  val asmDFA: DFA = {
    /* -- is "set difference" in scala, while ++ is "set union" for sets */
    val dfaAccepting: Set[String] = (asmTokens -- asmDotKeywords) ++ Set("WHITESPACE", "COMMENT")
    val dfaStates:    Set[String] = dfaAccepting ++ Set("DOT", "MINUS", "ZEROX", "DOLLARS", "START")
    val hexDigits                 = ('a' to 'f') ++ ('A' to 'F') ++ ('0' to '9')
    DFA(
      states     = dfaStates,
      start      = "START",
      alphabet   = ".;$,()".toSet ++ ('a' to 'z') ++ ('A' to 'Z') ++ ('0' to '9'),
      accepting  = dfaAccepting,
      /* A partial function is essentially a map: an association between keys (in this case a state & letter
       * with values (in this case another state). However, we can use the more powerful pattern matching
       * syntax to write them, such as how this DFA is defined.
       */
      transition = {
        case ("START",x)      if x.isLetter               => "ID"
        case ("ID",x)         if x.isLetterOrDigit        => "ID"
        case ("ID",':')                                   => "LABEL"
        case ("START",'.')                                => "DOT"
        case ("DOT",x)        if x.isLetterOrDigit        => "DOTID"
        case ("DOTID",x)      if x.isLetterOrDigit        => "DOTID"
        case ("START",'0')                                => "ZERO"
        case ("ZERO",'x')                                 => "ZEROX"
        case ("ZERO",x)       if x.isDigit                => "INT"
        case ("ZEROX",x)      if hexDigits contains x     => "HEXINT"
        case ("HEXINT",x)     if hexDigits contains x     => "HEXINT"
        case ("START",x)      if x.isDigit                => "INT"
        case ("INT",x)        if x.isDigit                => "INT"
        case ("START",'-')                                => "MINUS"
        case ("MINUS",x)      if x.isDigit                => "INT"
        case ("START",';')                                => "COMMENT"
        case ("COMMENT",x)    if x != '\n'                => "COMMENT"
        case ("START",x)      if x.isWhitespace           => "WHITESPACE"
        case ("WHITESPACE",x) if x.isWhitespace           => "WHITESPACE"
        case ("START",'$')                                => "DOLLARS"
        case ("DOLLARS",x)    if x.isDigit                => "REG"
        case ("REG",x)        if x.isDigit                => "REG"
        case ("START",',')                                => "COMMA"
        case ("START",'(')                                => "LPAREN"
        case ("START",')')                                => "RPAREN"
      }
    )
  }

  /* A scanned token, which stores both its kind and lexeme.
   * You could improve the error messages generated by this scanner by also remembering line number and column
   * information.
   *
   * Contains the toInt and toHexLong convenience methods to translate HEXINT and INT token lexemes to integral types.
   * They should not be called on other kinds of tokens.
   */
  case class Token(kind: String, lexeme: String) {
    /* Should only be called on tokens of type REG, HEXINT, and INT */
    def toLong: Long = {
      kind match {
        case "INT" => lexeme.toLong
        case "REG" => lexeme.substring(1).toLong
        case "HEXINT" => java.lang.Long.parseUnsignedLong(lexeme.substring(2),16)
      }
    }
  }

  /* An implementation of the Simplified Maximal Munch algorithm,
   * which will be presented in class around the time of Assignment 6.
   */
  def simplifiedMaximalMunch(dfa: DFA, input: List[Char]): Seq[Token] = {
    /* Munch the longest possible token and return it along with the remaining unconsumed input */
    def scanOne(input: List[Char], state: String = dfa.start, consumedInput: List[Char] = Nil): (List[Char], Token) =
      if (input.isEmpty || !dfa.transition.isDefinedAt((state,input.head)))
        if (dfa.accepting contains state) (input,Token(state,consumedInput.reverse.mkString))
        else sys.error(s"ERROR: simplified maximal munch failed on input: ${consumedInput.reverse ++ input}")
      else scanOne(input.tail, dfa.transition((state,input.head)), input.head :: consumedInput)

    /* Repeatedly call scanOne until the input is consumed or an error occurs */
    def scanAll(input: List[Char], accum: List[Token] = Nil): Seq[Token] = input match {
      case Nil => accum.reverse
      case _   =>
        val (remainingInput, tok) = scanOne(input)
        scanAll(remainingInput, tok :: accum)
    }
    scanAll(input)
  }

  def scan(input: String): Seq[Token] = {
    /* Keywords are scanned as ID and DOTID, so we need to convert them to the correct token types */
    /* Map can accept a partial function if you use curly braces {} instead of parens ().
     * In this case we give it a pattern match which distinguishes tokens of type ID and DOTID
     * from other tokens.
     */
    val tokens = simplifiedMaximalMunch(asmDFA, input.toList).map {
      case Token("DOTID", x) if asmDotKeywords contains x.substring(1).toUpperCase       =>
        Token(x.substring(1).toUpperCase, x)
      case Token("DOTID", _)                                                             =>
        sys.error("ERROR: Unrecognized DOTID token lexeme")
      case Token("ZERO",s)                                                               =>
        Token("INT",s)
      case t                                                                             =>
        t
        /* Scala tip: For lambda functions which only use their argument in one place, you can
         * usually use an _ rather than defining a variable explicitly. The filter below is
         * equivalent to filter(x => asmTokens contains x.kind)
         */
    }.filter(asmTokens contains _.kind) /* Remove whitespace and comments */

    /* The scanner accepts ints and registers of any size, but we only want to accept sufficiently small ones */
    def checkRange(t: Token): Unit = {
      try {
        t match {
          case Token("INT",x)    =>
            if (t.toLong > 4294967295l || x.toLong < -2147483648l) sys.error(s"ERROR: Integer out of range: ${t.lexeme}")
          case Token("HEXINT",_) =>
            if (t.toLong > 4294967295l) sys.error(s"ERROR: Hexint out of range: ${t.lexeme}")
          case Token("REG",x)    =>
            if (t.toLong > 31l || t.toLong < 0l) sys.error(s"ERROR: Register out of range: ${t.lexeme}")
          case _                   => Unit
        }
      } catch {
        case e: NumberFormatException => sys.error(s"ERROR: Integer out of range: ${t.lexeme}")
      }
    }

    tokens.foreach(checkRange)

    tokens
  }
}
